const cron = require('node-cron');
const db = require('./db');
const axios = require('axios');

// Kimi K2.5 NLP Analysis via NVIDIA NIM API
async function analyzeTextWithKimi(batchText) {
    try {
        const apiKey = process.env.NVIDIA_API_KEY;
        if (!apiKey) {
            console.error("‚ùå [NLP Error] NVIDIA_API_KEY is missing from environment variables.");
            return null;
        }

        const url = "https://integrate.api.nvidia.com/v1/chat/completions";

        const systemPrompt = `
Voc√™ √© um assistente de extra√ß√£o de dados estrito e militar focado em ocorr√™ncias geogr√°ficas da cidade de Ub√°, Minas Gerais.
Sua miss√£o √© ler um imenso bloco de not√≠cias rasgadas da internet e identificar interdi√ß√µes de vias p√∫blicas, pontos alagados, quedas de barreiras ou pontes colapsadas.

Regras de Extra√ß√£o e Resposta:
1. Ignore qualquer evento que n√£o seja explicitamente dentro do munic√≠pio de Ub√°-MG.
2. Extraia o NOME DA RUA/AVENIDA mais exato poss√≠vel (Ex: "Avenida Beira-Rio", "MG-447", "Ponte Major Fusaro").
3. Determine o "status" da via como EXATAMENTE UM DE: "total" (interdi√ß√£o total/inundado), "parcial" (meia pista), "bridge" (risco/queda de ponte).
4. VOC√ä DEVE RESPONDER UNICA E EXCLUSIVAMENTE COM UM ARRAY JSON VALIDADO. Sem formata√ß√£o Markdown, sem a palavra "json" no come√ßo, sem sauda√ß√µes.

Se n√£o houver nenhum incidente relatado nas not√≠cias providas, retorne exatamente um array vazio:
[]

Se houver 1 ou mais incidentes, retorne exatamente neste formato de Array de Objetos:
[
  { "hasIncident": true, "streetName": "Avenida Governador Valadares", "status": "total" },
  { "hasIncident": true, "streetName": "Rodovia MG-447", "status": "parcial" }
]
`;

        const payload = {
            "model": "moonshotai/kimi-k2.5",
            "messages": [
                { "role": "system", "content": systemPrompt },
                { "role": "user", "content": `[LOTE DE NOT√çCIAS PARA PROCESSAR]:\n\n${batchText}` }
            ],
            "max_tokens": 4096,
            "temperature": 0.1,
            "top_p": 1.00,
            "stream": false,
            "chat_template_kwargs": { "thinking": true }
        };

        const headers = {
            "Authorization": `Bearer ${apiKey}`,
            "Content-Type": "application/json",
            "Accept": "application/json"
        };

        const response = await axios.post(url, payload, { headers, timeout: 60000 }); // Kimi thinking takes time
        const aiRawOutput = response.data.choices[0].message.content.trim();

        // Defensive JSON parsing
        let parsedArray = [];
        try {
            // Strip potential accidental markdown block formatting generated by AI
            const jsonStr = aiRawOutput.replace(/```json/g, '').replace(/```/g, '').trim();
            parsedArray = JSON.parse(jsonStr);
        } catch (parseError) {
            console.error("‚ùå [NLP Error] Failed to parse Kimi JSON response:", aiRawOutput);
            return null;
        }

        if (!Array.isArray(parsedArray)) {
            return null;
        }

        return parsedArray; // Array of incident objects

    } catch (error) {
        console.error("‚ùå [NLP Error] NVIDIA API Request Failed:", error.response?.status, error.response?.data || error.message);
        return null;
    }
}

// Main Cron Job Logic - Batch Strategy
function startScraper() {
    console.log('Automated Scraping Engine Initialized (Kimi K2.5). Running every 30 mins.');

    cron.schedule('*/30 * * * *', async () => {
        console.log('[Scraping/NLP/Batch] Running the 30min routine...');

        try {
            // 1. Fetch REAL data from local portals (BATCH STRATEGY)
            console.log("-> Harvesting HTML from News Portals...");
            const portalPromises = [
                axios.get('https://www.guiamuriae.com.br/noticias/cidade/uba/', { timeout: 10000 }).catch(e => ({ data: "" })),
                // More sources can be added to this batch array easily without increasing API costs
                // axios.get('https://ubaempauta.com.br/', { timeout: 10000 }).catch(e => ({ data: "" }))
            ];

            const results = await Promise.all(portalPromises);

            // 2. Aggregate raw HTML (sliced to keep within model memory & avoid token bloat)
            let aggregatedHTML = "";
            results.forEach((res, index) => {
                if (res && res.data) {
                    // Extract ~8000 chars from each portal (Kimi has 128k context, so we are safe)
                    aggregatedHTML += `\n--- FONTE ${index + 1} ---\n` + res.data.substring(0, 8000);
                }
            });

            if (aggregatedHTML.length < 50) {
                console.log("‚ö†Ô∏è Batch harvest failed or is empty, skipping cycle.");
                return;
            }

            // 3. Pass Aggregated Batch to Kimi K2.5
            console.log("-> Sending Batch to NVIDIA Kimi K2.5 for Cognitive Processing...");
            const incidentArray = await analyzeTextWithKimi(aggregatedHTML);

            if (incidentArray && incidentArray.length > 0) {
                console.log(`[NLP Validation] Kimi detected ${incidentArray.length} potential incident(s). Syncing DB...`);

                // 4. Update the Database iteratively for each valid finding
                incidentArray.forEach(nlpResult => {
                    if (!nlpResult.hasIncident || !nlpResult.streetName) return;

                    db.get('SELECT id FROM Streets WHERE name LIKE ?', [`%${nlpResult.streetName}%`], (err, street) => {
                        if (err || !street) {
                            console.log(`‚ö†Ô∏è Kimi found incident, but street '${nlpResult.streetName}' is not in Database Map.`);
                            return;
                        }

                        // Check if community already reported it (Cross-check)
                        db.get('SELECT id FROM Reports WHERE streetId = ?', [street.id], (err, report) => {
                            if (err) return;

                            if (report) {
                                // Validate existing community report
                                db.run('UPDATE Reports SET isOfficial = 1, status = ? WHERE id = ?', [nlpResult.status, report.id]);
                                console.log(`‚úÖ [Validation] Community report validation confirmed for ${nlpResult.streetName}!`);
                            } else {
                                // Create brand new official auto-report
                                db.run(
                                    "INSERT INTO Reports (streetId, userId, status, description, isOfficial) VALUES (?, NULL, ?, ?, 1)",
                                    [street.id, nlpResult.status, "Extra√ß√£o via IA Kimi K2.5 dos portais locais."]
                                );
                                console.log(`üìù [Auto-Post] Kimi system created an Official Alert for ${nlpResult.streetName}.`);
                            }
                        });
                    });
                });

            } else {
                console.log('‚úÖ [Scraping/NLP] Cicle finished. Kimi did not find any street incidents in this news batch.');
            }
        } catch (err) {
            console.error('[Scraping/NLP] Global Engine Error:', err.message);
        }
    });
}

module.exports = { startScraper };
